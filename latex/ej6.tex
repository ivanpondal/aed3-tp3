\section{Metaheurística \emph{tabu search}}

% A esta altura ya se cansaron de escuchar las peleas entre Marty y el Doc,
% con lo cual les dejaron muy en claro que lo último que les ofrecen es
% implementar una metaheurística para resolver el problema. Por suerte, fueron
% tomados en serio, así que evaluaron todos juntos la situación y decidieron
% que lo mejor es utilizar la metaheurística Taboo Search. Para ponerle punto
% final a esta historia, deberán diseñar e implementar un algoritmo para MCS
% que incluya la susodicha metaheurística, y desarrollar los siguientes puntos
% que validen la solución encontrada, para que finalmente reine el amor y la
% igualdad entre Marty y el Doc:
% a) Explicar detalladamente el algoritmo implementado. Plantear distintos
%    criterios de parada y de tamaño de la lista taboo de la heurística.
% b) Realizar una experimentación que permita observar los tiempos de
%    ejecución y la calidad de las soluciones obtenidas. Se debe experimentar
%    variando los valores de los parámetros de la metaheurística (tamaño de la
%    lista taboo, criterios de parada, etc.) y las vecindades utilizadas en la
%    búsqueda local. Elegir, si es posible, la configuración que mejores
%    resultados provea para el grupo de instancias utilizado.

\subsection{Introducción}
Para mejorar los resultados obtenidos mediante la heurística de búsqueda
local, se implementó una metaheurística \emph{tabu search}. Esta
metaheurística tiene como objetivo realizar una ejecución guiada de la
heurística de búsqueda local, evitando el estancamiento en óptimos locales;
para esto, se continúan explorando soluciones incluso aunque resulten menos
óptimas, con la esperanza de encontrar mejores resultados a largo plazo. Para
evitar la generación de ciclos por un retorno constante a los óptimos locales
ya encontrados, se utiliza una \emph{lista tabú}, donde se almacenan
soluciones o características de soluciones que no deberían volver a visitarse.
También se puede almacenar información adicional, por ejemplo, una valoración
de las soluciones consideradas \emph{tabú} que permita decidir entre ellas en
caso de no existir alternativa.

\subsection{Características}
Dado que la metaheurística no es más que un esquema algorítmico general, para
definir la implementación de la metaheurística, fue necesario tomar decisiones
sobre varios puntos, que serán expuestos a continuación.

\subsubsection{Estructura del algoritmo}
La metaheurística se implementó utilizando como base la heurística de búsqueda
local presentada en la sección anterior, manteniendo la posibilidad de
elegir cuál de las dos vecindades considerar. El esquema de ejecución es muy
sencillo:
\begin{enumerate}
    \item Se ejecuta la heurística golosa, para utilizar la solución obtenida
    como punto de partida.
    \item Se ejecuta una iteración de la heurística de búsqueda local, con la
    vecindad elegida. De esta forma se determina un \emph{movimiento} hacia
    una solución vecina, que para ambas vecindades puede representarse
    mediante un par de vértices de $G_2$ involucrados en la transformación: en
    el caso de la vecindad I o de la operación \emph{exchange} de la vecindad
    II, uno de los vértices pertenece al mapeo de la solución actual y el otro
    no, mientras que en la operación \emph{swap} de la vecindad II ambos nodos
    pertenecen al mapeo.
    \item Se agrega a la lista tabú el movimiento inverso al realizado, para
    indicar que no se desea revertirlo en el futuro.
    \item Si no se cumple el criterio de parada elegido, se repite el paso 2,
    pero prohibiendo realizar movimientos que se encuentren en la lista tabú.
\end{enumerate}

La diferencia entre este esquema metaheurístico y los algoritmos de búsqueda
local es que, si al explorar la vecindad, todas las soluciones vecinas
evaluadas resultan ser peores que la actual, se permite realizar un movimiento
hacia una de ellas, que es elegida de forma aleatoria.

\subsubsection{Lista tabú}

\subsubsection{Criterio de eliminación}
Dado que la capacidad de la lista tabú es limitada, se hace necesario contar
con un criterio para decidir qué elementos eliminar de la misma cuando no hay
espacio para almacenar movimientos nuevos. La opción más sencilla es,
posiblemente, adoptar un enfoque \acr{FIFO}: cuando hay que eliminar un
elemento, se selecciona el que más tiempo lleva en la lista. Sin embargo, esto
puede ocasionar que movimientos que dieron muy buenos resultados (y que por
lo tanto, no se desea revertir) sean rápidamente desplazados de la lista por
movimientos menos significativos, lo cual no es deseable.

Para solucionar este inconveniente, se decidió adoptar un criterio de
eliminación híbrido. A cada elemento de la lista tabú se le asocia un peso, y
cada vez que debe descartarse uno de ellos, se selecciona aquel cuyo peso es
menor. El peso de un movimiento dado es directamente proporcional a la
cantidad de aristas aportadas, e inversamente proporcional al tiempo que lleva
en la lista, pudiendo regularse la influencia de cada uno de estos factores en
el cálculo mediante un parámetro $c \in [0,1]$. La fórmula utilizada para
calcular el peso de un movimiento, en función de la cantidad $a$ de aristas
aportadas y de la cantidad $t$ de iteraciones que lleva en la lista tabú, es
\[ P(t,a,c) = c \left( \frac{a + m} {2 m} \right) + (1-c) \left(\frac{1}{1+0.1t} \right) \]
donde:
\begin{itemize}
    \item $m = \max_{v \in V(G_1)} \deg(v)$. Este valor fue seleccionado
    porque, en cualquiera de las dos vecindades planteadas para la búsqueda
    local, un movimiento cualquiera puede agregar o restar, a lo sumo, $m$
    aristas de la solución. De esta forma $-m < a < m$, por lo que el valor
    del primer término de la fórmula anterior resulta ser un número entre $0$
    y $1$.
    \item El segundo término de la suma es también un valor entre $0$ y $1$, y
    además el valor del mismo disminuye cada vez más lentamente a medida que
    pasa el tiempo. Esto favorece que los movimientos que aportan poca
    cantidad de aristas sean rápidamente descartados de la lista, mientras que
    los que resultan más significativos desarrollan cierta ``resistencia'' a
    ser eliminados.
\end{itemize}

Notar que, con esta definición, el valor del peso para un movimiento
determinado es siempre un valor entre $0$ y $1$. Cada vez que se agrega un
nuevo elemento a la lista tabú, se calcula su peso con $t = 0$, y los pesos de
todos los demás elementos son actualizados sumando $1$ al valor anterior de
$t$. La lista, por su parte, es una cola de prioridad donde la prioridad de
cada elemento es su peso; esto permite seleccionar en tiempo constante el
próximo elemento a ser eliminado, y actualizar el peso de todos los demás en
un tiempo lineal en el tamaño de la lista.

\subsubsection{Criterio de parada}

\subsubsection{Función de aspiración}

\subsection{Experimentación}
