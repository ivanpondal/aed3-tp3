\section{Ejercicio 2}

% Para convencer a Marty, el Doc necesita mostrarle un algoritmo que
% efectivamente resuelva el problema. Dado que sus habilidades de programador
% están un poco oxidadas, se les pide diseñar e implementar un algoritmo
% exacto para MCS y desarrollar los siguientes puntos que justifiquen la
% solución encontrada:
% a) Explicar detalladamente el algoritmo implementado. Elaborar podas y
%    estrategias que permitan mejorar los tiempos de resolución.
% b) Calcular el orden de complejidad temporal de peor caso del algoritmo.
% c) Realizar una experimentación que permita observar los tiempos de
%    ejecución del algoritmo en función del tamaño de entrada y de las podas
%    y/o estrategias implementadas.

\subsection{Introducción}
En este ejercicio, se busca encontrar un algoritmo exacto para resolver, en
tiempo exponencial, el problema del \acr{MCS} entre dos grafos cualquiera.
Para ello utilizamos el método de \textit{Backtracking}. Este método es
extremadamete costoso tanto temporal como espacialmente, por lo que no sólo
es recomendable sino condición del ejercicio realizar podas y estrategias que
permitan mejorar los tiempos de resolución.

\subsection{Resolución}
El algoritmo consiste en probar todos los mapeos posibles entre los nodos de
ambos grafos, y así tomar un grafo común con la mayor cantidad de aristas de
entre todas las combinaciones de mapeos.

Dentro de la función principal, aquella que emplea la técnica de
\textit{Backtracking}, se hace uso de ambos grafos, dos listas enlazadas $L_1, L_2$ (una
para cada grafo) que contienen los ids de los nodos aún no mapeados en esta
rama de ejecución, y un mapa implementado sobre una tabla de hash que contiene
los mapeos hechos en esa rama de ejecución. Se iteran $L_1$ y $L_2$ mediante
dos ciclos anidados