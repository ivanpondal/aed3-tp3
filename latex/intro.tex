\section*{Introducción}
\addcontentsline{toc}{section}{Introducción}

En el presente trabajo, se explorarán distintos alogoritmos para la resolución
del problema de grafos conocido como \emph{máximo subgrafo común}, o
\acr{MCS} (\emph{maximum commom subgraph}). Este problema consiste en
encontrar, dados dos grafos cualesquiera, un tercer grafo que sea,
simultáneamente, isomorfo a algún subgrafo de los dos primeros, y con la
máxima cantidad posible de aristas.

Más formalmente, si $G_1 = (V_1, E_1)$ y $G_2 = (V_2, E_2)$ son dos grafos
simples, el problema de máximo subgrafo común consiste en encontrar un grafo
$H = (V_H, E_H)$, isomorfo tanto a un subgrafo de $G_1$ como a un subgrafo
de $G_2$ que maximice $\#E(H)$.

Encontrar el \acr{MCS} entre dos grafos es un problema NP-
completo\cite{garey}, por lo que, a menos que $\text{P} = \text{NP}$, no
existen algoritmos que permitan resolver el caso general en tiempo polinomial.
Por este motivo, el problema es abordado en este trabajo desde dos enfoques
distintos, según se favorezca la exactitud o el rendimiento temporal de las
soluciones.

En primer lugar, se presentan dos algoritmos exactos: uno de complejidad
temporal exponencial que resuelve el caso general aplicando la técnica de
\emph{backtracking}, y otro restringido a un caso particular del problema
(cuando se tienen como entrada un grafo completo y un \emph {cografo}), cuya
complejidad temporal es polinomial. A continuación, se exploran tres
soluciones heurísticas (heurística golosa, heurística de búsqueda local, y
metaheurística \emph{tabu search}), que renuncian a la exactitud del enfoque
previo en pos de lograr una complejidad polinomial para el caso general. Por
último, se realiza un comparativo entre los resultados obtenidos para
distintos tipos de grafos utilizando cada una de las técnicas, extrayendo
conclusiones acerca de la calidad y la eficiencia de las mismas.

\subsection*{Consideraciones generales}
\addcontentsline{toc}{subsection}{Consideraciones generales}

\begin{enumerate}[label=(\roman*)]
\item Es importante notar que el problema de \acr{MCS} admite una formulación
equivalente, donde el subgrafo común buscado, $H$, es visto como un mapeo
biyectivo entre un subconjunto de los nodos de $G_1$ y un subconjunto de los
nodos de $G_2$. Más aún, suponiendo sin pérdida de generalidad que $\#V(G_1)
\leq \#V(G_2)$, esto es, que $G_1$ tiene una cantidad de nodos menor o igual
que la de $G_2$, el mapeo puede tomarse considerando la totalidad de los nodos
de $G_1$. Esto se debe a que, si ya se cuenta con una solución cuya cantidad
de aristas es máxima y que no utiliza todos los nodos de $G_1$, esta puede
extenderse para incluir los nodos faltantes sin perjudicar su optimalidad,
siendo los mismos mapeados a nodos arbitarios de $G_2$.

Para formalizar un poco más esta perspectiva, sean $G_1$ y $G_2$ tales que
$\#V(G_1) \leq \#V(G_2)$, y $H$ una solución de \acr{MCS} con $\#V(H) =
\#V(G_1)$. Entonces, existen un mapeo biyectivo entre los nodos de $H$ y los
de $G_1$, y un mapeo inyectivo entre los nodos de $H$ y los de $G_2$. Esto nos
permite definir $s : V(G_1) \to V (G_2)$, de forma tal que a todo $v \in
V(G_1)$ le corresponda el mismo nodo de $H$ que a $s(v) \in V(G_2)$; visto de
otro modo, cada nodo de $H$ se corresponde con un par de la forma $(v, s(v))$.

Más aún, conociendo $s$, las aristas de $H$ quedan unívocamente determinadas:
si dos nodos de $H$ correspondientes a los pares $(v, s(v))$ y $(w, s(w))$,
respectivamente, están unidos por una arista, entonces para que $H$ sea una
solución válida de \acr{MCS}, $(v, w)$ deberá ser una arista de $G_1$ y
$(s(v), s(w))$ deberá ser una arista de $G_2$. Recíprocamente, si tanto $v$ y
$w$ como $s(v)$ y $s(w)$ son adyacentes en sus respectivos grafos, los nodos
correspondientes en $H$ a cada par deberán ser adyacentes, o el número de
aristas de $H$ no sería máximo. De todo lo anterior, se sigue que para dar una
solución a \acr{MCS} basta con exhibir un mapeo $s : V(G_1) \to V (G_2)$
apropiado.

Dado que esta interpretación del problema simplifica la formulación
e implementación de muchos de los procedimientos expuestos en este trabajo,
será utilizada asiduamente a lo largo del mismo.

\item Todos los algoritmos presentados en el trabajo fueron implementados en
el lenguaje C++, utilizando en varios casos funciones y estructuras de datos
provistas por la biblioteca estándar del lenguaje. Estas implementaciones
fueron sometidas a diversas pruebas experimentales, durante las cuales se
tuvieron en cuenta las siguientes consideraciones generales:

\begin{itemize}
\item Solo se midió el costo temporal de generar las soluciones,
omitiendo el demandado para la lectura y escritura de los datos.
\item Para la medición de los tiempos de ejecución, se utilizaron los
métodos proporcionados por el \emph{header} \texttt{chrono} de la
biblioteca estándar de C++. Los tiempos fueron medidos en nanosegundos.
% \item Todas las pruebas se corrieron en las computadoras del Laboratorio 4
% del Departamento de Computación (\acr{FCEN} - \acr{UBA}).
% \item Todos los experimentos aleatorios se realizaron con semilla de valor 7.
\end{itemize}

\end{enumerate}
