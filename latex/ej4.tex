\section{Heurística golosa}

% Desgraciadamente, el problema es tan difícil que ni Marty ni el Doc conocen
% una manera de resolverlo en tiempo polinomial para el caso general. Para no
% quedarse con las manos vacías, Marty les pide diseñar e implementar una
% heurística constructiva golosa para MCS y desarrollar los siguientes puntos
% para conocer la calidad de las soluciones que le proveerán:
% a) Explicar detalladamente el algoritmo implementado.
% b) Calcular el orden de complejidad temporal de peor caso del algoritmo.
% c) Describir instancias de MCS para las cuales la heurística no proporciona
%    una solución óptima. Indicar qué tan mala puede ser la solución obtenida
%    respecto de la solución óptima.
% d) Realizar una experimentación que permita observar la performance del
%    algoritmo en términos de tiempo de ejecución en función del tamaño de
%    entrada.

\subsection{Introducción}

Dado que la complejidad del algoritmo exacto resulta prohibitiva en la práctica,
se pedía desarrollar una heurística golosa que resolviera el problema en tiempo
polinomial. Para esto fue necesario plantear algoritmos que a cuestas de la
calidad final de la solución permitieran mejorar sustancialmente la complejidad.

Pensar heurísticas tiene el desafío de que las mismas suelen tener un factor
importante de intuición sobre por qué podrían llegar a funcionar mejor o peor y
no una justificación formal. Esto tiene como consecuencia que resulta
difícil decidir qué criterio utilizar puesto que siempre es posible
encontrar instancias para las cuales el mismo sea tan malo como uno
quiera.

El criterio seleccionado fue el grado de los nodos. La motivación detrás de esta
decisión fue la idea de que tomando los vértices de mayor grado en cada grafo,
uno aumenta la posibilidad de que tengan vecinos en común, permitiendo así mapear
sus respectivas aristas en el subgrafo común.

\subsection{Resolución algorítmica}

Se desarrollaron dos algoritmos golosos. El primero trabaja únicamente con la idea de mapear
los nodos de grado mayor de ambos grafos. El segundo toma el algoritmo anterior con
la diferencia de que además de mapear los nodos, agrega el mayor número posible de
vecinos de los mismos. Esta pequeña variación se utilizó como para tener una
alternativa contra la cual comparar. Luego de pruebas que serán discutidas en la
sección de experimentación, se llegó a la conclusión de que esta variación
brindaba soluciones peores que el primer algoritmo, con lo cual todo futuro
análisis será dedicado a este.

El mecanismo del algoritmo es el siguiente:
\begin{enumerate}
	\item Se utilizan dos colas de prioridad para tener los nodos de cada grafo
	ordenados por mayor grado.
	\item Desencolando el primer nodo de cada cola se forma un par que es agregado al subgrafo común.
	\item Si hay vecinos de los nodos del nuevo par mapeados al mismo elemento del
	subgrafo común, se agrega una arista entre ellos.
\end{enumerate}

A continuación, el pseudocódigo de la heurística implementada:

\begin{algorithm}[H]
	\SetAlgoVlined
	\caption{Heurística golosa}
	\Input{Dos grafos $G_1$ y $G_2$}
	\Output{Un subgrafo común entre $G_1$ y $G_2$}
	\textit{subgrafo\_común} $\gets$ Crear grafo de pares vacío \;
	\textit{nodos\_sin\_visitar\_g1} $\gets$ Crear cola de prioridad con nodos de $G_1$ utilizando
	su grado como peso \;
	\textit{nodos\_sin\_visitar\_g2} $\gets$ Crear cola de prioridad con nodos de $G_2$ utilizando
	su grado como peso \;

	\textit{vecinos\_mapeados} $\gets$ Crear conjunto de pares vacío \;
	\While{\textit{nodos\_sin\_visitar\_g1} y \textit{nodos\_sin\_visitar\_g2}
	no estén vacíos}{
		\textit{nodo\_g1} $\gets$ Desencolar primero de
		\textit{nodos\_sin\_visitar\_g1} \;
		\textit{nodo\_g2} $\gets$ Desencolar primero de
		\textit{nodos\_sin\_visitar\_g2} \;
		Agregar nodo (\textit{nodo\_g1}, \textit{nodo\_g2}) a
		\textit{subgrafo\_común} \;

		\ForEach{\textit{vecino} de \textit{nodo\_g1}}{
			\If{\textit{vecino} está mapeado en \textit{subgrafo\_común}}{
				Agregar mapeo de \textit{vecino} a \textit{vecinos\_mapeados} \;
			}
		}

		\ForEach{\textit{vecino} de \textit{nodo\_g2}}{
			\If{\textit{vecino} está mapeado en \textit{subgrafo\_común} y el
			mapeo está en \textit{vecinos\_mapeados}}{
				Agregar arista entre (\textit{nodo\_g1}, \textit{nodo\_g1}) y
				mapeo de \textit{vecino} en \textit{subgrafo\_común} \;
			}
		}
		Vaciar \textit{vecinos\_mapeados} \;
	}
	\Return{\textit{subgrafo\_común}}
\end{algorithm}

\subsection{Complejidad}

La complejidad temporal queda en función de la entrada: $G_1 = (V_1, E_1)$ y $G_2 = (V_2,
E_2)$.

Inicializar las dos colas de prioridad tiene un costo $\ord(N_1 \times \log N_1 + N_2
\times \log N_2)$. Esto se debe a que las mismas están implementadas sobre un heap cuyo costo
de inserción es logarítmico sobre la cantidad de elementos en el mismo.

El ciclo princpial corre hasta que alguna de las dos colas se vacíe. En el peor caso
ambas colas tienen el mismo tamaño, con lo cual se desencolarían los $N_1 = N_2$
nodos. En cada iteración del ciclo se recorren todos los vecinos de los nodos
desapilados donde para cada uno se realiza una operación de costo constante.
Como estamos asumiendo que se recorren todos los vértices de cada grafo esto
corresponde a la siguiente sumatoria:

\begin{equation*}
	\ord(\sum_{v \in V_1}^{} \deg(v) + \sum_{v \in V_2}^{} \deg(v)) =
	\ord(2 \times M_1 + 2 \times M_2) = \ord(M_1 + M_2)
\end{equation*}

Una vez finalizado el ciclo, se retorna el subgrafo común encontrado, por lo
tanto el costo final del algoritmo es:

\begin{equation*}
	\ord(N_1 \times \log N_1 + N_2 \times \log N_2 + M_1 + M_2)
\end{equation*}

\subsection{Instancias subóptimas}\label{sec:ej4:suboptimal}

Como se dijo anteriormente, una heurística puede funcionar relativamente bien
para algunas instancias y sin embargo ser desastrosa para otras. Para este
problema en particular, las instancias son los pares de grafo ($G_1$, $G_2$) que
son recibidos como entrada.

La heurística golosa desarrollada utiliza fuertemente la intuición de que los
nodos de mayor grado al poseer más vecinos tienen una mayor posibilidad de
agregar aristas contra el subgrafo común generado hasta el momento. Como es de
esperarse, esto puede llevar por mal camino.

Se procede a describir la construcción para una familia de instancias donde el
algoritmo no es capaz de encontrar ninguna arista independientemente del tamaño
de los grafos:

\begin{enumerate}
	\item Crear un ciclo $C_k$ en $G_1$ y $G_2$ con $k \geq 3$.
	\item Crear $k$ estrellas $K_{1,3}$ en $G_1$.
\end{enumerate}

Esto resulta en un grafo $G_1$ con $N_1 = 5 \times k$ y $M_1 = 4 \times k$,
y otro grafo $G_2$ con $N_2 = k$ y $M_2 = k$. Por lo tanto, las instancias
pueden ser tan grandes como uno desee.

El máximo subgrafo común de esta familia siempre será el ciclo $C_k$. Esto se
debe a que $G_2 = C_k$, por lo tanto es subgrafo de $G_1$ que contiene a $C_k$.

El grado máximo de $G_1$ será 3, correspondiente al de los nodos
centrales en cada estrella $K_{1,3}$. En $G_2$ el grado máximo será 2, ya que al
ser un ciclo simple todo vértice tendrá ese número de aristas incidentes.

\begin{figure}[H]
	\centering
	\includegraphics{imagenes/ex4.pdf}
	\caption{Ejemplo de instancia de la familia para $k = 3$.}
	\label{fig:heuristica-golosa:ejemplo-g1-suboptimo}
\end{figure}

Habiendo presentado las características de esta instancia es posible demostrar
que el algoritmo no es capaz de realizar ni un solo mapeo de arista válido.

Previamente se explicó que la heurística golosa encola todos los nodos de cada
grafo utilizando su grado como prioridad. Esto produce que para $G_1$ estén
primeros todos los nodos centrales de las estrellas $K_{1,3}$ mientras que para
$G_2$ los vértices que componen el ciclo. Al entrar al ciclo principal, se mapea
cada nodo central de alguna estrella de $G_1$ con un vértice perteneciente al
ciclo de $G_2$. Como hay $k$ estrellas y $G_2 = C_k$ cada nodo del ciclo
termina siendo mapeado al vértice central de un $K_{1,3}$.

Este mapeo tiene la particularidad de que no permite agregar ninguna arista, y
esto se debe a que para poder mapear una arista, es necesario que para el par de
nodos a agregar, exista en el subgrafo común un par mapeado con vecinos de ambos
vértices. Cada estrella pertenece a una componente conexa distinta, con lo cual
no hay ninguna arista entre dos estrellas distintas. Como consecuencia, ningún
nodo central de una estrella es vecino a otro. De esta forma, ningún par de
vértices mapeados de $G_1$ es vecino entre sí, produciendo que no sea posible
agregar una arista en el subgrafo común generado.

\begin{figure}[H]
	\centering
	\includegraphics{imagenes/ex4_solution.pdf}
	\caption{$H$ solución generada por la heurística y $MCS$ el máximo subgrafo
	común para la instancia en Figura \ref{fig:heuristica-golosa:ejemplo-g1-suboptimo}.}
	\label{fig:heuristica-golosa:ejemplo-g1-suboptimo-solucion}
\end{figure}

Esto vale para cualquier instancia de esta familia con $k \geq 3$, donde el
algoritmo siempre va a actuar de la misma manera con el peor resultado posible
que es no encontrar ni una arista en común.

\subsection{Experimentación}

\pgfplotstableread[header=false]{../exp/ej4/known_sol_greedy_exp}\knowngreedy
\pgfplotstableread[header=false]{../exp/optimal_solutions}\optimalsolutions

\pgfplotstableset{
	create on use/sol/.style={copy column from table={\optimalsolutions}{[index] 1}}
}

\pgfplotstabletypeset[
	every head row/.style={
		after row=\hline
	},
	columns={0, sol, 1, 3, 4},
	columns/0/.style={
		column name=\textsc{Instancia},
		column type={l},
		string replace*={_}{\_},
		string type,
		assign cell content/.code={
			\pgfkeyssetvalue{/pgfplots/table/@cell content}{\texttt{##1}}
		}
	},
	columns/sol/.style={
		column name=$\#E(MCS)$,
		int detect
	},
	columns/1/.style={
		column name=$\#E(H)$,
		int detect
	},
	columns/3/.style={
		column name=$T_{\mu}$,
	},
	columns/4/.style={
		column name=$T_{\sigma}$,
	}
]\knowngreedy
