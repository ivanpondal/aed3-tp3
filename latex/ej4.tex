\section{Heurística golosa}

% Desgraciadamente, el problema es tan difícil que ni Marty ni el Doc conocen
% una manera de resolverlo en tiempo polinomial para el caso general. Para no
% quedarse con las manos vacías, Marty les pide diseñar e implementar una
% heurística constructiva golosa para MCS y desarrollar los siguientes puntos
% para conocer la calidad de las soluciones que le proveerán:
% a) Explicar detalladamente el algoritmo implementado.
% b) Calcular el orden de complejidad temporal de peor caso del algoritmo.
% c) Describir instancias de MCS para las cuales la heurística no proporciona
%    una solución óptima. Indicar qué tan mala puede ser la solución obtenida
%    respecto de la solución óptima.
% d) Realizar una experimentación que permita observar la performance del
%    algoritmo en términos de tiempo de ejecución en función del tamaño de
%    entrada.

\subsection{Introducción}

Dado que la complejidad del algoritmo exacto resulta prohibitiva en la práctica,
se pedía desarrollar una heurística golosa que resolviera el problema en tiempo
polinomial. Para esto fue necesario plantear algoritmos que a cuestas de la
calidad final de la solución permitieran mejorar sustancialmente la complejidad.

Pensar heurísticas tiene el desafío de que las mismas suelen tener un factor
importante de intuición sobre por qué podrían llegar a funcionar mejor o peor y
no una justificación formal. Esto tiene como consecuencia que resulta
difícil decidir qué criterio utilizar puesto que siempre es posible
encontrar instancias para las cuales el mismo sea tan malo como uno
quiera.

El criterio seleccionado fue el grado de los nodos. La motivación detrás de esta
decisión fue la idea de que tomando los vértices de mayor grado en cada grafo,
uno aumenta la posibilidad de que tengan vecinos en común, permitiendo así mapear
sus respectivas aristas en el subgrafo común.

\subsection{Resolución algorítmica}

Se desarrollaron dos algoritmos golosos. El primero trabaja únicamente con la idea de mapear
los nodos de grado mayor de ambos grafos. El segundo toma el algoritmo anterior con
la diferencia de que además de mapear los nodos, agrega el mayor número posible de
vecinos de los mismos. Esta pequeña variación se utilizó como para tener una
alternativa contra la cual comparar. Luego de pruebas que serán discutidas en la
sección de experimentación, se llegó a la conclusión de que esta variación
brindaba soluciones peores que el primer algoritmo, con lo cual todo futuro
análisis será dedicado a este.

El mecanismo del algoritmo es el siguiente:
\begin{enumerate}
	\item Se utilizan dos colas de prioridad para tener los nodos de cada grafo
	ordenados por mayor grado.
	\item Desencolando el primer nodo de cada cola se forma un par que es agregado al subgrafo común.
	\item Si hay vecinos de los nodos del nuevo par mapeados al mismo elemento del
	subgrafo común, se agrega una arista entre ellos.
\end{enumerate}

A continuación, el pseudocódigo de la heurística implementada:

\begin{algorithm}[H]
	\SetAlgoVlined
	\caption{Heurística golosa}
	\Input{Dos grafos $G_1$ y $G_2$}
	\Output{Un subgrafo común entre $G_1$ y $G_2$}
	\textit{subgrafo\_común} $\gets$ Crear grafo de pares vacío \;
	\textit{nodos\_sin\_visitar\_g1} $\gets$ Crear cola de prioridad con nodos de $G_1$ utilizando
	su grado como peso \;
	\textit{nodos\_sin\_visitar\_g2} $\gets$ Crear cola de prioridad con nodos de $G_2$ utilizando
	su grado como peso \;

	\textit{vecinos\_mapeados} $\gets$ Crear conjunto de pares vacío \;
	\While{\textit{nodos\_sin\_visitar\_g1} y \textit{nodos\_sin\_visitar\_g2}
	no estén vacíos}{
		\textit{nodo\_g1} $\gets$ Desencolar primero de
		\textit{nodos\_sin\_visitar\_g1} \;
		\textit{nodo\_g2} $\gets$ Desencolar primero de
		\textit{nodos\_sin\_visitar\_g2} \;
		Agregar nodo (\textit{nodo\_g1}, \textit{nodo\_g2}) a
		\textit{subgrafo\_común} \;

		\ForEach{\textit{vecino} de \textit{nodo\_g1}}{
			\If{\textit{vecino} está mapeado en \textit{subgrafo\_común}}{
				Agregar mapeo de \textit{vecino} a \textit{vecinos\_mapeados} \;
			}
		}

		\ForEach{\textit{vecino} de \textit{nodo\_g2}}{
			\If{\textit{vecino} está mapeado en \textit{subgrafo\_común} y el
			mapeo está en \textit{vecinos\_mapeados}}{
				Agregar arista entre (\textit{nodo\_g1}, \textit{nodo\_g1}) y
				mapeo de \textit{vecino} en \textit{subgrafo\_común} \;
			}
		}
		Vaciar \textit{vecinos\_mapeados} \;
	}
	\Return{\textit{subgrafo\_común}}
\end{algorithm}

\subsection{Experimentación}

\pgfplotstableread[header=false]{../exp/ej4/known_sol_greedy_exp}\knowngreedy
\pgfplotstableread[header=false]{../exp/optimal_solutions}\optimalsolutions

\pgfplotstableset{
	create on use/sol/.style={copy column from table={\optimalsolutions}{[index] 1}}
}

\pgfplotstabletypeset[
	every head row/.style={
		after row=\hline
	},
	columns={0, sol, 1, 3, 4},
	columns/0/.style={
		column name=\textsc{Instancia},
		column type={l},
		string replace*={_}{\_},
		string type,
		assign cell content/.code={
			\pgfkeyssetvalue{/pgfplots/table/@cell content}{\texttt{##1}}
		}
	},
	columns/sol/.style={
		column name=$\#E(MCS)$,
		int detect
	},
	columns/1/.style={
		column name=$\#E(H)$,
		int detect
	},
	columns/3/.style={
		column name=$T_{\mu}$,
	},
	columns/4/.style={
		column name=$T_{\sigma}$,
	}
]\knowngreedy
