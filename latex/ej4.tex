\section{Heurística golosa}

% Desgraciadamente, el problema es tan difícil que ni Marty ni el Doc conocen
% una manera de resolverlo en tiempo polinomial para el caso general. Para no
% quedarse con las manos vacías, Marty les pide diseñar e implementar una
% heurística constructiva golosa para MCS y desarrollar los siguientes puntos
% para conocer la calidad de las soluciones que le proveerán:
% a) Explicar detalladamente el algoritmo implementado.
% b) Calcular el orden de complejidad temporal de peor caso del algoritmo.
% c) Describir instancias de MCS para las cuales la heurística no proporciona
%    una solución óptima. Indicar qué tan mala puede ser la solución obtenida
%    respecto de la solución óptima.
% d) Realizar una experimentación que permita observar la performance del
%    algoritmo en términos de tiempo de ejecución en función del tamaño de
%    entrada.

\subsection{Introducción}

Dado que la complejidad del algoritmo exacto resulta prohibitiva en la práctica,
se pedía desarrollar una heurística golosa que resolviera el problema en tiempo
polinomial. Para esto fue necesario plantear algoritmos que a cuestas de la
calidad final de la solución permitieran mejorar sustancialmente la complejidad.

Pensar heurísticas tiene el desafío de que las mismas suelen tener un factor
importante de intuición sobre por qué podrían llegar a funcionar mejor o peor y
no una justificación formal. Esto tiene como consecuencia que resulta
difícil decidir qué criterio utilizar puesto que siempre es posible
encontrar instancias para las cuales el mismo sea tan malo como uno
quiera.

El criterio seleccionado fue el grado de los nodos. La motivación detrás de esta
decisión fue la idea de que tomando los vértices de mayor grado en cada grafo,
uno aumenta la posibilidad de que tengan vecinos en común, permitiendo así mapear
sus respectivas aristas en el subgrafo común.

\subsection{Experimentación}

\pgfplotstableread[header=false]{../exp/ej4/known_sol_greedy_exp}\knowngreedy
\pgfplotstableread[header=false]{../exp/optimal_solutions}\optimalsolutions

\pgfplotstableset{
	create on use/sol/.style={copy column from table={\optimalsolutions}{[index] 1}}
}

\pgfplotstabletypeset[
	every head row/.style={
		after row=\hline
	},
	columns={0, sol, 1, 3, 4},
	columns/0/.style={
		column name=\textsc{Instancia},
		column type={l},
		string replace*={_}{\_},
		string type,
		assign cell content/.code={
			\pgfkeyssetvalue{/pgfplots/table/@cell content}{\texttt{##1}}
		}
	},
	columns/sol/.style={
		column name=$\#E(MCS)$,
		int detect
	},
	columns/1/.style={
		column name=$\#E(H)$,
		int detect
	},
	columns/3/.style={
		column name=$T_{\mu}$,
	},
	columns/4/.style={
		column name=$T_{\sigma}$,
	}
]\knowngreedy
